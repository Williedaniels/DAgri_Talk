name: Monitoring and Observability

on:
  schedule:
    # Run monitoring checks every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:
  push:
    branches: [main, develop]
    paths:
      - 'monitoring/**'
      - '.github/workflows/monitoring.yml'

env:
  AWS_REGION: us-east-1

jobs:
  health-check:
    name: Application Health Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Check application health
      run: |
        # Get ALB DNS name from Terraform output
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names dagri-talk-dev-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "Checking health of: https://$ALB_DNS"
        
        # Health check with retry logic
        for i in {1..3}; do
          if curl -f -s "https://$ALB_DNS/api/health" > /dev/null; then
            echo "✅ Health check passed (attempt $i)"
            break
          else
            echo "❌ Health check failed (attempt $i)"
            if [ $i -eq 3 ]; then
              exit 1
            fi
            sleep 30
          fi
        done
    
    - name: Check frontend availability
      run: |
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names dagri-talk-dev-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        # Check if frontend loads
        if curl -f -s "https://$ALB_DNS" | grep -q "D'Agri Talk"; then
          echo "✅ Frontend is accessible"
        else
          echo "❌ Frontend check failed"
          exit 1
        fi
    
    - name: Performance test
      run: |
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names dagri-talk-dev-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        # Simple performance test
        echo "Running performance test..."
        
        response_time=$(curl -o /dev/null -s -w '%{time_total}' "https://$ALB_DNS/api/health")
        echo "Response time: ${response_time}s"
        
        # Alert if response time > 2 seconds
        if (( $(echo "$response_time > 2.0" | bc -l) )); then
          echo "⚠️ High response time detected: ${response_time}s"
          # Could trigger alert here
        else
          echo "✅ Response time acceptable: ${response_time}s"
        fi

  metrics-collection:
    name: Collect Custom Metrics
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install boto3 requests psutil
    
    - name: Collect and send metrics
      run: |
        python3 << 'EOF'
        import boto3
        import requests
        import json
        from datetime import datetime
        
        cloudwatch = boto3.client('cloudwatch', region_name='us-east-1')
        
        # Get ALB DNS
        elbv2 = boto3.client('elbv2', region_name='us-east-1')
        alb_response = elbv2.describe_load_balancers(Names=['dagri-talk-dev-alb'])
        alb_dns = alb_response['LoadBalancers'][0]['DNSName']
        
        try:
            # Test API response time
            start_time = datetime.now()
            response = requests.get(f'https://{alb_dns}/api/health', timeout=10)
            end_time = datetime.now()
            
            response_time = (end_time - start_time).total_seconds()
            
            # Send custom metrics to CloudWatch
            metrics = [
                {
                    'MetricName': 'HealthCheckResponseTime',
                    'Value': response_time,
                    'Unit': 'Seconds',
                    'Dimensions': [
                        {
                            'Name': 'Environment',
                            'Value': 'production'
                        },
                        {
                            'Name': 'Source',
                            'Value': 'github-actions'
                        }
                    ]
                },
                {
                    'MetricName': 'HealthCheckStatus',
                    'Value': 1 if response.status_code == 200 else 0,
                    'Unit': 'Count',
                    'Dimensions': [
                        {
                            'Name': 'Environment',
                            'Value': 'production'
                        }
                    ]
                }
            ]
            
            cloudwatch.put_metric_data(
                Namespace='DAgriTalk/Monitoring',
                MetricData=metrics
            )
            
            print(f"✅ Metrics sent successfully. Response time: {response_time}s")
            
        except Exception as e:
            print(f"❌ Error collecting metrics: {e}")
            
            # Send failure metric
            cloudwatch.put_metric_data(
                Namespace='DAgriTalk/Monitoring',
                MetricData=[
                    {
                        'MetricName': 'HealthCheckStatus',
                        'Value': 0,
                        'Unit': 'Count',
                        'Dimensions': [
                            {
                                'Name': 'Environment',
                                'Value': 'production'
                            }
                        ]
                    }
                ]
            )
        EOF

  security-monitoring:
    name: Security Monitoring
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Check for security alerts
      run: |
        # Check CloudWatch alarms
        aws cloudwatch describe-alarms \
          --state-value ALARM \
          --query 'MetricAlarms[?contains(AlarmName, `DAgriTalk`)].{Name:AlarmName,State:StateValue,Reason:StateReason}' \
          --output table
        
        # Count active alarms
        alarm_count=$(aws cloudwatch describe-alarms \
          --state-value ALARM \
          --query 'length(MetricAlarms[?contains(AlarmName, `DAgriTalk`)])' \
          --output text)
        
        echo "Active alarms: $alarm_count"
        
        if [ "$alarm_count" -gt "0" ]; then
          echo "⚠️ Active security/performance alarms detected!"
          # Could trigger notifications here
        else
          echo "✅ No active alarms"
        fi
    
    - name: Check recent errors
      run: |
        # Query CloudWatch Logs for recent errors
        aws logs start-query \
          --log-group-name "/aws/ecs/dagri-talk-backend" \
          --start-time $(date -d '1 hour ago' +%s) \
          --end-time $(date +%s) \
          --query-string 'fields @timestamp, @message | filter @message like /ERROR/ | sort @timestamp desc | limit 10' \
          > query_result.json
        
        query_id=$(cat query_result.json | jq -r '.queryId')
        
        # Wait for query to complete
        sleep 10
        
        # Get results
        aws logs get-query-results --query-id "$query_id" \
          --query 'results[*][1].value' \
          --output text > recent_errors.txt
        
        if [ -s recent_errors.txt ]; then
          echo "⚠️ Recent errors found:"
          cat recent_errors.txt
        else
          echo "✅ No recent errors found"
        fi

  generate-monitoring-report:
    name: Generate Monitoring Report
    runs-on: ubuntu-latest
    needs: [health-check, metrics-collection, security-monitoring]
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Generate monitoring report
      run: |
        cat > monitoring_report.html << 'EOF'
        <!DOCTYPE html>
        <html>
        <head>
            <title>D'Agri Talk - Monitoring Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background: #2c3e50; color: white; padding: 20px; border-radius: 5px; }
                .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
                .success { background: #d4edda; border-color: #c3e6cb; }
                .warning { background: #fff3cd; border-color: #ffeaa7; }
                .error { background: #f8d7da; border-color: #f5c6cb; }
                .metric { display: inline-block; margin: 10px; padding: 10px; background: #f8f9fa; border-radius: 3px; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>D'Agri Talk - Monitoring Report</h1>
                <p>Generated: $(date)</p>
            </div>
        EOF
        
        # Add health check results
        if [ "${{ needs.health-check.result }}" == "success" ]; then
          echo '<div class="section success"><h2>✅ Health Check: PASSED</h2><p>Application is healthy and responsive</p></div>' >> monitoring_report.html
        else
          echo '<div class="section error"><h2>❌ Health Check: FAILED</h2><p>Application health check failed</p></div>' >> monitoring_report.html
        fi
        
        # Add metrics collection results
        if [ "${{ needs.metrics-collection.result }}" == "success" ]; then
          echo '<div class="section success"><h2>✅ Metrics Collection: SUCCESS</h2><p>Custom metrics collected and sent to CloudWatch</p></div>' >> monitoring_report.html
        else
          echo '<div class="section warning"><h2>⚠️ Metrics Collection: ISSUES</h2><p>Some metrics collection issues detected</p></div>' >> monitoring_report.html
        fi
        
        # Add security monitoring results
        if [ "${{ needs.security-monitoring.result }}" == "success" ]; then
          echo '<div class="section success"><h2>✅ Security Monitoring: CLEAR</h2><p>No security alerts detected</p></div>' >> monitoring_report.html
        else
          echo '<div class="section warning"><h2>⚠️ Security Monitoring: ALERTS</h2><p>Security monitoring detected issues</p></div>' >> monitoring_report.html
        fi
        
        # Get current metrics
        python3 << 'PYTHON_EOF'
        import boto3
        from datetime import datetime, timedelta
        
        cloudwatch = boto3.client('cloudwatch', region_name='us-east-1')
        
        # Get recent metrics
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=1)
        
        try:
            # Request count
            response = cloudwatch.get_metric_statistics(
                Namespace='AWS/ApplicationELB',
                MetricName='RequestCount',
                Dimensions=[
                    {
                        'Name': 'LoadBalancer',
                        'Value': 'dagri-talk-dev-alb'
                    }
                ],
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Sum']
            )
            
            request_count = response['Datapoints'][0]['Sum'] if response['Datapoints'] else 0
            
            # Response time
            response = cloudwatch.get_metric_statistics(
                Namespace='AWS/ApplicationELB',
                MetricName='TargetResponseTime',
                Dimensions=[
                    {
                        'Name': 'LoadBalancer',
                        'Value': 'dagri-talk-dev-alb'
                    }
                ],
                StartTime=start_time,
                EndTime=end_time,
                Period=3600,
                Statistics=['Average']
            )
            
            avg_response_time = response['Datapoints'][0]['Average'] if response['Datapoints'] else 0
            
            print(f'<div class="section">')
            print(f'<h2>📊 Current Metrics (Last Hour)</h2>')
            print(f'<div class="metric"><strong>Total Requests:</strong> {int(request_count)}</div>')
            print(f'<div class="metric"><strong>Avg Response Time:</strong> {avg_response_time:.3f}s</div>')
            print(f'</div>')
            
        except Exception as e:
            print(f'<div class="section warning"><h2>⚠️ Metrics Unavailable</h2><p>Error: {e}</p></div>')
        PYTHON_EOF >> monitoring_report.html
        
        # Close HTML
        echo '</body></html>' >> monitoring_report.html
        
        echo "Monitoring report generated: monitoring_report.html"
    
    - name: Upload monitoring report
      uses: actions/upload-artifact@v4
      with:
        name: monitoring-report
        path: monitoring_report.html
        retention-days: 30

  alert-on-failure:
    name: Alert on Monitoring Failure
    runs-on: ubuntu-latest
    needs: [health-check, metrics-collection, security-monitoring]
    if: failure()
    
    steps:
    - name: Send alert notification
      run: |
        echo "🚨 MONITORING ALERT: D'Agri Talk monitoring detected issues!"
        echo "Timestamp: $(date)"
        echo "Health Check: ${{ needs.health-check.result }}"
        echo "Metrics Collection: ${{ needs.metrics-collection.result }}"
        echo "Security Monitoring: ${{ needs.security-monitoring.result }}"
        
        # In a real implementation, you would send this to:
        # - Slack webhook
        # - Email notification
        # - PagerDuty
        # - SMS alert service
        
        # Example Slack notification (requires SLACK_WEBHOOK_URL secret):
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"🚨 D'\''Agri Talk monitoring alert detected!"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}